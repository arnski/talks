<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Abseits von PHP - Node.js</title>

	<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
	<meta name="author" content="Hakim El Hattab">

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="css/reveal.min.css">
	<link rel="stylesheet" href="css/theme/default.css" id="theme">

	<!-- For syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- If the query includes 'print-pdf', use the PDF print sheet -->
	<script>
	document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
	</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<img src="img/php_dude.jpg">

				</section>
				<section>
					<h1>
						<br>
					</h1>
					<h1>Abseits von PHP</h1>

				</section>				
				<section>
					<section>
						<h2>
							<img src="img/nodejs-logo.png">
						</h2>
					</section>
					<section>
						<h2>
							<font face="helvetica">
								<b>Warum?</b>
							</font>
						</h2>
					</section>
					<section>
						<div>
							<img src="img/fire.png">
						</div>
						It's HOT!
					</section>
					<section>
						<div>
							<img src="img/hipsters11.jpg" height="500px">
						</div>
						Hipster Hacker
					</section>
					<section>
						<img src="img/brogrammer_purcell.jpg">
						<br>
						Brogrammer 
					</section>
					<section>
					  <img src="img/frameworks_irc.jpg">
					</section>
					<section>
					  <img src="img/github_top_languages.jpg">
					  <aside class="notes">Auch bei den Top Repositories ist Node weit vor Symfony</aside>
					</section>
					<section>
					  <img src="img/npm_stats.jpg">
					</section>
					<section>
					  <img src="img/packagist_stats.jpg">
					</section>
				</section>
				<section>
				  <h2>TOC</h2>
				  <ul>
				    <li style="color:green">Warum Node? ✓</li>
				    <li>Kontext - JS</li>
				    <li>Kontext - Ruby</li>
				    <li>Node - Überblick</li>
				    <li>Node - Beispiele</li>
				    <li>NPM</li>
				    <li>Node - Beispiele</li>
				    <li>Fazit</li>
				    <li>Ausblick</li>
				  </ul>
				</section>
				<section>
					<section>
						<h2>JavaScript Eckpunkte (90ies)</h2>
						<img src="img/Brendan_Eich.jpg">
						<ul>
							<li class="fragment">1995: Brendan Eich entwickelt JS - in 10 Tagen</li>
							<li class="fragment">1996: Netscape Navigator 3 - JavaScript 1.1</li>
							<li class="fragment">1996: Internet Explorer 3 - JScript <= Beginn des Browserkrieges</li>
							<li class="fragment">1996: Mit Netscape "Livewire" erster Versuch JS => Server</li>
							<li class="fragment">1999: Huch! MS erfindet XMLHTTPObject. AJAX, Baby</li>		
						</ul>

						<aside class="notes">
							Zu <b>Brendan entwickelt JS - in 10 Tagen</b>: Laut eigener Aussage (Engine). N.B. Brendan Eich ist Mitbegründer und aktueller CTO von Mozilla.

							Zu <b>IE3 / JScript</b>: Wir erinnern uns: IE & Netscape Navigator stammen beide von der gleichen Code-Basis ab (Universität von Illinois). Microsoft hat mit IE3 zum ersten mal zu N.N. aufgeschlossen. Es hat mit dieser Version u.a. eine eigene JS- Implementation (JScript) hingelegt, die nicht deckungsgleich mit JavaScript war.
						</aside>
					</section>
					<section>
						<h2>JavaScript Eckpunkte (00er)</h2>
						<ul>
							<li class="fragment">2000: Douglas "The Crock" Crockford entdeckt *JSON* als Objektaustausch</li>
							<li class="fragment">2004: Gmail als SPA</li>
							<li class="fragment">2005: jQuery</li>
							<li class="fragment">2005: Adobe CS2 - skriptbar via JS</li>
							<li class="fragment">2006: CouchDB bringt JS in die DB- Welt</li>
							<li class="fragment">2008: Google Chrome & V8 - ungeahnte Performance => Engine Wars</li>
							<li class="fragment">2009: Ryan Dahl entwickelt Node.js</li>
						</ul>

						<aside class="notes">
							Zu <b>jQuery</b>: Hat es den bis dato verwirrten Frontend- Devs möglich gemacht, mit dem DOM umzugehen. Und damit Javascript attraktiv. Javascript ist u.a. durch jQuery extrem populär geworden.

							Zu <b>V8:</b> Google kommt mir v8 heraus. Sie sehen es als einen Weg, den das Web / den Browsermarkt (denken wir auch an Gmail) zu dominieren. Auf einmal stehen die anderen JS- Engine Hersteller unter Zugzwang auch zu optimieren. Und schwups - quasi über Nacht - ist JS schneller als Ruby und Python. 

							V8 steigerte die Leistung, indem u.a. der JavaScript-Code bei der Ausführung zunächst in nativen Maschinencode übersetzt wird (Just-in-time-Kompilierung), anstatt Bytecode auszuführen oder die Skriptsprache direkt zu interpretieren.
						</aside>
					</section>
					<section>
						<h2>JavaScript Eckpunkte (10er)</h2>
						<ul>
							<li class="fragment">2011: Node.js nun auch auf Windows ;)</li>
						</ul>

						<aside class="notes">
							Zu <b>Node auf Win</b>: Das lässt mich zum einen etwas schmunzeln, zum anderen bedeutet es: "Big Player" unterstützen Node. Und - Nach Unix und Mac ist Node nun "überall".
						</aside>
					</section>
					<section>
						<h2>JavaScript Eckpunkte (Zusammenfassung)</h2>
						<ul>
							<li>Javascript ist überall. Browser, Server, DB, TVs, Mobile Apps, Photoshop, ...</li>
							<li>Der Pool von Entwicklern ist riesig, und wächst, und wächst, ...</li>
							<li>Big Players - Google, Microsoft, Apple, Adobe, ... pumpen Geld in das JS- Ökosystem</li>
							<li>Der gedankliche "Quickie" v. Brendan Eich wird zur vermutl. am meisten verwandten Programmiersprache der Web-Welt.</li>
						</ul>
					</section>
          <aside class="notes">
              Zu <b>Pool v. Entw.:</b>Zum einen hat durch die weite Verbreitung von Ajax & später Prototype & jQuery wohl jeder schon einmal Code von zumindest mittlerer Komplexität in JS geschrieben. (Auch asynchron).
              Zum anderen hat es in den letzten Jahren einen wahren Boom an JS- Frameworks gegeben.
            </aside>
				</section>
				<section>
					<section>
					  <h1>Rewind: 2005-2008</h1>
						<aside class="notes">
						  Wo kommt Node ins Spiel? Spulen wir nochmal ein wenig zurück:
						  
						  Erinnern wir uns an die Jahre 2005-2008. Rails explodierte. Und mit Rails auch die Full- Stack Frameworks der anderen Scriptsprachen. 
              	
  						Ein viel diskutiertes Problem dieser Zeit war die Performance der Frameworks, insbesondere Rails.

  							Skalierbarkeit != Performance

  							<!-- Das Problem war nicht, das es nicht skaliert - ich meine, man konnte Twitter damit betreiben. Das Problem ist, wie schnell kann man eine wirklich dynamische Seite ausliefern. -->	

  							
  							Ich möchte mich hier nicht im Detail verlieren, unterm Strich steht jedoch, dass damals die Parallelisierung von Aufgaben wie z.B. Requestabarbeitung sehr schlecht funktionierte.



  							<!-- Jetzt kam hier noch die Geschichte mit den Upload Progress Bars - Ajax : Auch hier war offenbar Mongrel der erste Technoweenie Plugin (Flickr)-->

  							Er experimentierte nun zunächst mit ... <!-- ToDo: ergaenzen -->

  							So. Das war jetzt eine ganze Menge Kontext. Doch ...

						</aside>
					</section>
					<section>
            <h2>Rails & Fullstackframeworks</h2>
            <img src="img/ruby-on-rails-logo.png" height="80%">
            <img src="img/Performanceprobleme.jpg" class="fragment">
            <aside class="notes">
							Performance- Schwierigkeiten
						</aside>
					</section>
					<section>
					  <h2>Mongrel & Merb</h2>
					  <img src="img/Mongrel_2_logo.png" width="400px"><br>
					  <i>"No Code is faster than no code"</i>
					  <aside class="notes">
              Lösungsansätze: Mongrel & Merb
              
              Es gab einige Versuche, Rails schneller zu machen - u.A. Merb (Ein bisschen wie sf2 - Coole Tagline "No Code is faster than no code"). Merb hat quasi eine Reinraumversion des Rails Controllers genommen, und alles weitere in Module ausgelagert, die bei Bedarf hinzugenommen wurden. Merb behob unter anderem das "Request-Lock" von Rails: Bis die Response raus war, nichts anderes machen.
						</aside>
					</section>
					<section>
					  <h2>Mongrel</h2>
					  <img src="img/mongrel_request_response.jpg">
					  <aside class="notes">
					    * Shift des Verständnisses vom Webserver
					    ** Weg vom Ordner mit Skripten und Statics
					    ** Hin zu Konzept von Request & Response in Sprache selbst.
              * Mongrel = Bastard / Schäferhundmischling			   
				    </aside>
					</section>
					<section>
					  <h2>Merb</h2>
					  <img src="img/reinraum2.jpg" height="80%">
					  <aside class="notes">
					    * Reinraumversion von Rails Controller - mit Modularem Konzept für restliche Klassen
              * Merb wurde später (2010, Rails 3.0) mit Rails zusammengeführt
              * (sf2?!) ;)
				    </aside>
					</section>
					<section>
              <h1><i>"Ruby is at fault"</i></h1><br/>
              <img src="img/ruby.png" height="20%">
              <aside class="notes">
                Nach all den Mühen ist man jedoch schliesslich an den Punkt gekommen, an dem man gemerkt hat, dass das Problem an ganz anderer Stelle lag. Nicht Rails - sondern Ruby selbst hat das Performanceproblem.  

  							Es hatte, ähnlich wie Python ein eher beschränktes Threading Modell, Interpreter Locks, etc..                         

  							<!-- Hier evtl vertiefen - Rubys / Pythons schlechtes Threading, Interpreter Locks, etc. -->  				

              </aside>
  				</section>
					<section>
					  <img src="img/ryan_dahl.jpg"><br/>
					  <i>Ryan Dahl</i>
					</section>										
          <section>
            <img src="img/hmm_big.jpg" alt="description">
          </section>
          <section>
            <img src="img/Polydactyly_01_Lfoot_AP.jpg" alt="description">
            <aside class="notes">
              Zeh ++
            </aside>
          </section>
          <section>
					  <img src="img/lonely.jpg"><br/>
					</section>
					<section>
					  <img src="img/v8_logo.png"><br/>
					</section>
					<section>
					  <h1>BAM! Javascript!</h1>
					  <aside class="notes">
					    Vorher erwähnen: Es war schon die Idee mit dem Non-Blocking.
					    
					    Features: Anonymous Functions, Closures, aber insbesondere hat es niemand serverseitig genutzt. Es gab also keine Vorprägung in den Köpfen wie man JS benutzen soll..
					  </aside>
					</section>
				</section>				
			</section>
				<section>
					<section>
						<h1>Wat issen</h1><br />
						<h1 class="fragment">eigentlich</h1><br />
						<h1 class="fragment">Node.js?</h1>
					</section>
					<section>
						<img src="img/nodejs-logo.png" height="300">
						<br />
						<p style="font-family: 'Georgia';color: #669900">Node's goal is to provide an easy way to build scalable network programs. <br />Node.js uses an <strong>event-driven</strong>, <strong>non-blocking</strong> <strong>I/O</strong> model that makes it lightweight and efficient, perfect for data-intensive <strong>real-time</strong> applications that run across distributed devices.</font>

						<aside class="notes">
							Was das eigentlich bedeutet, schauen wir uns jetzt an.
						</aside>
					</section>
					<section>
						<img src="img/io-cost.png">
						<aside class="notes"><strong>Einleitung:</strong>Warum ist das wichtig?<br />
						  * Grafik: Die größte Verschwendung aktueller Programmiertechniken...Hier idlet der CPU<br />
						  * Man will aber viele Verbindungen gleichzeitig. Was kann man also machen:<br />
						  a) Synchron. Alle weiteren Prozesse warten auf Fertigstellung der vorigen<br />
						  b) Prozess forken
						  c) Threads
					</section>
					<section>
						<h2>Architektur</h2>
						<img src="img/nodejsarch.png" height="300">
            <aside class="notes">
              * Node erweitert v8 um ...<br />
              * libev (by Marc Lehmann) is an event loop similar to the well-known libevent. According to its author, libev outperforms libevent in multiple benchmarks. It is even able to emulate the libevent API.<br />
              * libeio (by Marc Lehmann) is a fantastic idea: it relies on POSIX threads to provide an asynchronous version of the POSIX API: open, close, stat, unlink, fdatasync, mknod, etc. <br />
              * c-ares (by Daniel Stenberg) provides an asynchronous DNS resolver.
              * Wir wollen uns im Folgenden näher die JS- Ebene ansehen
            </aside>
					</section>
					<section>
            <img src="img/node_api.jpg">
            <aside class="notes">
              Was bietet uns Node?<br />
              * Lowlevelige Biobliotheken die v8 um Server-Belange erweitern.<br />
              * Denkkonzept - Non Blocking IO => Programmierung<br />
              * Das "abgeben" teurer Operationen an etablierte "OS-Nahe" Bibliotheken, die sehr gut in Concurrency sind.
            </aside>
					</section>
					<section>
            Eventloop
					</section>
				</section>
				<section>
					<section>
						<h2>Basic Examples</h2>
						<aside class="notes">
							* Diese Examples bedienen sich der Standardfunktionalitäten von Node.<br/>
							* <strong>Überleitung:</strong> Die kommenden Beispiele integrieren Bibliotheken von Drittherstellern. Bevor wir die Beispiele ansehen, machen wir einen kurzen Ausflug zu NPM - den PM von Node.
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h2>NPM - Node Package Manager</h2>
						<aside class="notes">
						  * Zeigen: /slides/packages.js/Connect 2.7.3 vs express/1.x
							* NPM Registry.
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h2>Intermediate Examples</h2>
						<aside class="notes">
							Diese Examples bedienen sich weiterer Module aus der NPM Registry.
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h2>Awesome Examples</h2>
						* http://demo.tutorialzine.com/2012/08/nodejs-drawing-game/
						<aside class="notes">
							Diese Examples sind awesome.
						</aside>
					</section>
				</section>
				<section>
				  <section>
						<h2>Rekapitulation</h2>
						<ul>
							<li>Historie</li>
							<li>Problemstellung</li>
							<li>Architektur, Konzepte</li>
							<li>Node API</li>
							<li>Basic Examples</li>
							<li>NPM</li>
							<li>Awesome Examples</li>
						</ul>
					</section>
					<section>
						<h2>Fazit</h2>
						<ul>
							<li>Nicht schreiend und Arme wedelnd PHP hinter sich lassen</li>
						  <li>Hoffe, habe Interesse geweckt.</li>
							<li>Interessantes Gebiet, im Auge behalten</li>
						  <li>Schwerpunkt auf Kontext & Konzepte - Lehrsituation draussen ist 1a! Gibt viele (Video-) Tutorials. Man kommt sehr schnell rein.</li>
							<li>Code- Sharing, Templates & Models</li>
							<li>Site / App aus mehreren Sprachen-zusammesetzbar => Glue = Backbone / ESI ?</li>
						</ul>
						<aside class="notes">
						  <strong>Code Sharing</strong>: Vorne Templates, hinten Ganze Seiten.
						</aside>
					</section>
				  <section>
						<h2>Good Idea</h2>
						<ul>
							<li></li>
							<li></li>
							<li></li>
						</ul>
						<h2>Not Neccessarily Good Idea</h2>
						<ul>
							<li>Number Crunching</li>
							<li>CPU Intensive Tasks (in Node itself)</li>
							<li></li>
						</ul>
						<aside class="notes">
						  Neuer Hammer ? Nicht alles sind Nägel!
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h2>Ausblick</h2>
						Wir sehen uns wieder, wenn es heisst..
						<img src="img/Bonzi_Buddy_Mongo_Wrongo.png" class="fragment" height="80%"><br />
						<em class="fragment">(Darüber hinaus: Weitere "Abseits von PHP" Talks)</em>
					</section>
				</section>
			</div>


		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
				{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
				{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
					]
				});

</script>

</body>
</html>
